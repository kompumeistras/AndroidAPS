package app.aaps.core.ui.compose

import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.awaitEachGesture
import androidx.compose.foundation.gestures.awaitFirstDown
import androidx.compose.foundation.gestures.waitForUpOrCancellation
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.widthIn
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Add
import androidx.compose.material.icons.filled.Remove
import androidx.compose.material3.FilledTonalIconButton
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Slider
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.rememberUpdatedState
import androidx.compose.runtime.setValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.res.stringResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import app.aaps.core.interfaces.resources.ResourceHelper
import app.aaps.core.ui.R
import kotlinx.coroutines.delay
import java.text.DecimalFormat
import kotlin.math.roundToInt
import app.aaps.core.keys.R as KeysR

/**
 * Formats minutes as duration string: "Xh Ym" when >= 60, "X mins" otherwise.
 * Composable version using stringResource.
 */
@Composable
fun formatMinutesAsDuration(minutes: Int): String {
    return if (minutes >= 60) {
        val hours = minutes / 60
        val mins = minutes % 60
        stringResource(R.string.format_hour_minute, hours, mins)
    } else {
        stringResource(R.string.format_mins, minutes)
    }
}

/**
 * Formats minutes as duration string: "Xh Ym" when >= 60, "X mins" otherwise.
 * Non-composable version using ResourceHelper.
 */
fun formatMinutesAsDuration(minutes: Int, rh: ResourceHelper): String {
    return if (minutes >= 60) {
        val hours = minutes / 60
        val mins = minutes % 60
        rh.gs(R.string.format_hour_minute, hours, mins)
    } else {
        rh.gs(R.string.format_mins, minutes)
    }
}

/**
 * A Slider with +/- buttons on each side for fine-grained value control.
 * Optionally displays a clickable value label that opens a dialog for direct input.
 *
 * @param value Current value
 * @param onValueChange Called when value changes
 * @param valueRange The range of values the slider can represent
 * @param step The step size for +/- buttons (default 0.1)
 * @param controlPoints Pairs of (position [0-1], value) to create a non linear slider, if null slider is linear
 * @param showValue Whether to show a clickable value label (default false)
 * @param valueFormatResId Resource ID for formatting value with unit (e.g., "%1$.1f U" or "%1$d min")
 * @param formatAsInt If true, value is formatted as Int for stringResource (use with %d format strings)
 * @param valueFormat Format for the value (used for dialog and fallback)
 * @param unitLabel Unit label for dialog input suffix (deprecated, use unitLabelResId)
 * @param unitLabelResId Resource ID for unit label. When R.string.units_min, auto-formats as "Xh Ym"
 * @param dialogLabel Label for the input dialog
 * @param dialogSummary Summary/description for the input dialog
 * @param modifier Modifier for the Row container
 */
@Composable
fun SliderWithButtons(
    value: Double,
    onValueChange: (Double) -> Unit,
    valueRange: ClosedFloatingPointRange<Double>,
    step: Double = 0.1,
    controlPoints: List<Pair<Double, Double>>? = null,
    showValue: Boolean = false,
    valueFormatResId: Int? = null,
    formatAsInt: Boolean = false,
    valueFormat: DecimalFormat = DecimalFormat("0.0"),
    unitLabel: String = "",
    unitLabelResId: Int = 0,
    dialogLabel: String? = null,
    dialogSummary: String? = null,
    modifier: Modifier = Modifier
) {
    val minValue = valueRange.start
    val maxValue = valueRange.endInclusive
    var showDialog by remember { mutableStateOf(false) }

    // Normalise ControlPoints to ensure % and values are consistent with min & maxValue
    val normalizedControlPoints by remember(controlPoints, minValue, maxValue) {
        mutableStateOf(
            if (controlPoints != null) {
                // check controlPoints are valid
                require(controlPoints.size >= 2) { "At least 2 control points required" }
                require(controlPoints.first().first == 0.0) { "First point must have 0.0 position" }
                require(controlPoints.last().first == 1.0) { "Last point must have 1.0 position" }
                require(controlPoints.map { it.first }.zipWithNext { a, b -> a < b }.all { it }) {
                    "Control points must be in increasing order"
                }
                controlPoints
            } else {
                // linear ControlPoints by default
                listOf(0.0 to minValue, 1.0 to maxValue)
            }
        )
    }

    // Calculate slider position [0.1] from targetValue
    fun valueToPosition(targetValue: Double): Float {
        val clampedValue = targetValue.coerceIn(minValue, maxValue)

        // find the right segment
        for (i in 0 until normalizedControlPoints.size - 1) {
            val (startPos, startValue) = normalizedControlPoints[i]
            val (endPos, endValue) = normalizedControlPoints[i + 1]

            if (clampedValue in startValue..endValue || clampedValue in endValue..startValue) {
                // linear interpolation between the two points
                if (endValue == startValue) return startPos.toFloat()

                val segmentRatio = (clampedValue - startValue) / (endValue - startValue)
                val position = startPos + segmentRatio * (endPos - startPos)
                return position.toFloat()
            }
        }

        // Fallback: linear conversion (should never occur with valid points)
        return ((clampedValue - minValue) / (maxValue - minValue)).toFloat()
    }

    // Convert slider position [0-1] to targetValue
    fun positionToValue(position: Float): Double {
        val clampedPos = position.coerceIn(0f, 1f)
        // find slider segment
        for (i in 0 until normalizedControlPoints.size - 1) {
            val (startPos, startValue) = normalizedControlPoints[i]
            val (endPos, endValue) = normalizedControlPoints[i + 1]

            if (clampedPos in startPos.toFloat()..endPos.toFloat()) {
                // Linear interpolation within segment
                if (endPos == startPos) return startValue

                val segmentRatio = (clampedPos - startPos) / (endPos - startPos)
                return startValue + segmentRatio * (endValue - startValue)
            }
        }
        // Fallback: linear conversion (should never occur with valid points)
        return minValue + clampedPos * (maxValue - minValue)
    }

    // Calculate current position [0-1]
    val currentPosition = valueToPosition(value)
    val currentValue = value.coerceIn(minValue, maxValue)
    val posForCurrent = valueToPosition(currentValue)
    val posForCurrentPlusStep = valueToPosition(currentValue + step)
    val dynamicStepPos = (posForCurrentPlusStep - posForCurrent)

    // Check if this is minutes input for special formatting
    val isMinutesUnit = unitLabelResId == KeysR.string.units_min
    val resolvedUnitLabel = when {
        unitLabelResId != 0    -> stringResource(unitLabelResId)
        unitLabel.isNotEmpty() -> unitLabel
        else                   -> ""
    }

    Row(
        modifier = modifier,
        verticalAlignment = Alignment.CenterVertically
    ) {
        // Minus button
        RepeatingIconButton(
            onClick = {
                val newPos = (currentPosition - dynamicStepPos).coerceAtLeast(0f)
                val newValue = positionToValue(newPos)
                val roundedValue = roundToStep(newValue, step).coerceIn(minValue, maxValue)
                onValueChange(roundedValue)
            },
            enabled = value > minValue,
            modifier = Modifier.size(32.dp)
        ) {
            Icon(
                imageVector = Icons.Default.Remove,
                contentDescription = "-",
                modifier = Modifier.size(16.dp)
            )
        }

        // Non-Linear Slider
        Slider(
            value = currentPosition,
            onValueChange = { newPos ->
                val newValue = positionToValue(newPos)
                val rounded = roundToStep(newValue, step)
                onValueChange(rounded.coerceIn(minValue, maxValue))
            },
            valueRange = 0f..1f,
            modifier = Modifier.weight(1f)
        )

        // Plus button
        RepeatingIconButton(
            onClick = {
                val newPos = (currentPosition + dynamicStepPos).coerceAtMost(1f)
                val newValue = positionToValue(newPos)
                val roundedValue = roundToStep(newValue, step).coerceIn(minValue, maxValue)
                onValueChange(roundedValue)
            },
            enabled = value < maxValue,
            modifier = Modifier.size(32.dp)
        ) {
            Icon(
                imageVector = Icons.Default.Add,
                contentDescription = "+",
                modifier = Modifier.size(16.dp)
            )
        }

        // Optional clickable value label
        if (showValue) {
            val displayText = when {
                // Special formatting for minutes >= 60 as "Xh Ym"
                isMinutesUnit                  -> formatMinutesAsDuration(value.roundToInt())

                valueFormatResId != null       -> {
                    if (formatAsInt) {
                        stringResource(valueFormatResId, value.roundToInt())
                    } else {
                        stringResource(valueFormatResId, value)
                    }
                }

                resolvedUnitLabel.isNotEmpty() -> "${valueFormat.format(value)} $resolvedUnitLabel"
                else                           -> valueFormat.format(value)
            }
            Text(
                text = displayText,
                style = MaterialTheme.typography.bodyMedium,
                fontWeight = FontWeight.Medium,
                color = MaterialTheme.colorScheme.primary,
                textAlign = TextAlign.End,
                modifier = Modifier
                    .widthIn(min = if (isMinutesUnit || valueFormatResId != null || resolvedUnitLabel.isNotEmpty()) 70.dp else 40.dp)
                    .clickable { showDialog = true }
                    .padding(start = 4.dp)
            )
        }
    }

    // Value input dialog
    if (showDialog) {
        ValueInputDialog(
            currentValue = value,
            valueRange = valueRange,
            step = step,
            label = dialogLabel,
            summary = dialogSummary,
            unitLabel = resolvedUnitLabel,
            unitLabelResId = unitLabelResId,
            valueFormat = valueFormat,
            onValueConfirm = onValueChange,
            onDismiss = { showDialog = false }
        )
    }
}

private fun roundToStep(value: Double, step: Double): Double {
    val scaled = (value / step).roundToInt() * step
    // Fix floating point precision errors (e.g., 6.1000000000005 -> 6.1)
    val decimals = step.toString().substringAfter('.', "").length
    val factor = Math.pow(10.0, decimals.toDouble())
    return Math.round(scaled * factor) / factor
}

/**
 * An icon button that repeats its onClick action while being held down.
 * Speed increases progressively the longer the button is held.
 */
@Composable
private fun RepeatingIconButton(
    onClick: () -> Unit,
    enabled: Boolean,
    modifier: Modifier = Modifier,
    initialDelayMs: Long = 500L,
    maxDelayMs: Long = 200L,
    minDelayMs: Long = 50L,
    accelerationFactor: Float = 0.8f,
    content: @Composable () -> Unit
) {
    var isPressed by remember { mutableStateOf(false) }
    val currentOnClick by rememberUpdatedState(onClick)

    LaunchedEffect(isPressed, enabled) {
        if (isPressed && enabled) {
            delay(initialDelayMs)
            var currentDelay = maxDelayMs.toFloat()
            while (isPressed && enabled) {
                currentOnClick()
                delay(currentDelay.toLong())
                currentDelay = (currentDelay * accelerationFactor).coerceAtLeast(minDelayMs.toFloat())
            }
        }
    }

    FilledTonalIconButton(
        onClick = onClick,
        enabled = enabled,
        modifier = modifier.pointerInput(Unit) {
            awaitEachGesture {
                awaitFirstDown(requireUnconsumed = false)
                isPressed = true
                waitForUpOrCancellation()
                isPressed = false
            }
        }
    ) {
        content()
    }
}
